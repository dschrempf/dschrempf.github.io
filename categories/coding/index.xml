<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding on Concept → IO ()</title>
    <link>https://blog.composef.org/categories/coding/</link>
    <description>Recent content in Coding on Concept → IO ()</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Sep 2025 00:00:00 +0200</lastBuildDate>
    <atom:link href="https://blog.composef.org/categories/coding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Notes on MuniHac 2025 talks</title>
      <link>https://blog.composef.org/coding/2025-09-19-munihac-2025/</link>
      <pubDate>Fri, 19 Sep 2025 00:00:00 +0200</pubDate>
      <guid>https://blog.composef.org/coding/2025-09-19-munihac-2025/</guid>
      <description>&lt;p&gt;MuniHac has happened again. I enjoyed it a lot. Below you can find my personal&#xA;notes on the talks. Free free to contact me if you have any comments!&lt;/p&gt;&#xA;&lt;div class=&#34;ox-hugo-toc toc&#34;&gt;&#xA;&lt;div class=&#34;heading&#34;&gt;Table of Contents&lt;/div&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#rodrigo-mesquita-a-modern-step-through-debugger-for-haskell&#34;&gt;Rodrigo Mesquita: A modern step-through debugger for Haskell&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#ga%C3%ABl-deest-hindsight-type-safe-evolvable-event-sourcing&#34;&gt;Gaël Deest: Hindsight - Type-safe, evolvable event sourcing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#andrew-lelechenko-linear-haskell-for-string-builders&#34;&gt;Andrew Lelechenko: Linear Haskell for string builders&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#steve-shuck-the-pcre2-regular-expression-library&#34;&gt;Steve Shuck: The &lt;code&gt;pcre2&lt;/code&gt; regular expression library&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#tommy-engstr%C3%B6m-domaindriven-type-safe-event-sourcing-in-haskell&#34;&gt;Tommy Engström: &lt;code&gt;domaindriven&lt;/code&gt; - Type-safe event sourcing in Haskell&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#joe-warren-how-i-use-haskell-for-3d-printing&#34;&gt;Joe Warren: How I use Haskell for 3D printing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#mike-sperber-six-years-of-funar-teaching-software-architecture-and-functional-programming-to-the-uninitiated&#34;&gt;Mike Sperber: Six years of FUNAR - Teaching software architecture and functional programming to the uninitiated&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/div&gt;&#xA;&lt;!--endtoc--&gt;&#xA;&lt;h2 id=&#34;rodrigo-mesquita-a-modern-step-through-debugger-for-haskell&#34;&gt;Rodrigo Mesquita: A modern step-through debugger for Haskell&lt;/h2&gt;&#xA;&lt;p&gt;&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;[2025-09-12 Fri 11:30]&lt;/span&gt;&lt;/span&gt;&#xA;&lt;a href=&#34;https://youtu.be/urYtE15ryA0&#34;&gt;Link to talk&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Advent of code (2023)</title>
      <link>https://blog.composef.org/coding/2023-12-02-advent-of-code-2023/</link>
      <pubDate>Sat, 02 Dec 2023 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2023-12-02-advent-of-code-2023/</guid>
      <description>&lt;p&gt;&lt;em&gt;Alle Jahre wieder &amp;hellip;&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;I am not sure how far I get this year, but writing Haskell is just too much fun.&#xA;Have a look at &lt;a href=&#34;https://github.com/dschrempf/aoc23&#34;&gt;my solutions to the Advent of code, 2023&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Cheers!&lt;/p&gt;&#xA;&lt;p&gt;PS: I even added automatic fetching of the full input as well as the samples&#xA;(see &lt;a href=&#34;https://github.com/dschrempf/aoc23/blob/main/app/Fetch.hs&#34;&gt;Fetch.hs&lt;/a&gt;). For example,&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cabal run fetch &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Fetch full input of day one.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cabal run fetch &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Fetch sample one of day one.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Advent of code (2022)</title>
      <link>https://blog.composef.org/coding/2022-12-02-advent-of-code-2022/</link>
      <pubDate>Fri, 02 Dec 2022 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2022-12-02-advent-of-code-2022/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://mmhaskell.com/blog/2022/11/30/advent-of-code-2022&#34;&gt;Everybody&lt;/a&gt; &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/z9mjcz/advent_of_code_2022_day_1/&#34;&gt;posts&lt;/a&gt; &lt;a href=&#34;https://news.ycombinator.com/item?id=33811958&#34;&gt;their&lt;/a&gt; &lt;a href=&#34;https://wjwh.eu/posts/2022-11-30-haskell-aoc-tricks.html&#34;&gt;solutions&lt;/a&gt; &lt;a href=&#34;https://gitlab.com/slotThe/advent2022&#34;&gt;in&lt;/a&gt; &lt;a href=&#34;https://github.com/borisskert/Advent-of-Code-2022.hs&#34;&gt;Haskell&lt;/a&gt; to the &lt;a href=&#34;https://adventofcode.com/2022&#34;&gt;Advent of code&lt;/a&gt; (described well&#xA;on &lt;a href=&#34;https://en.wikipedia.org/wiki/Advent_of_Code&#34;&gt;Wikipedia&lt;/a&gt;). So I thought I am going to join the crowd.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dschrempf/advent-of-code-twentytwo&#34;&gt;&lt;strong&gt;Here are mine&lt;/strong&gt;&lt;/a&gt;! I did clean the code after submission, but I did not change&#xA;anything substantial such as algorithms or data structures.&lt;/p&gt;&#xA;&lt;p&gt;(&lt;a href=&#34;https://github.com/Scriptim/AdventOfCode2022&#34;&gt;Want&lt;/a&gt; &lt;a href=&#34;https://github.com/hrichharms/AoC_2022&#34;&gt;some&lt;/a&gt; &lt;a href=&#34;https://github.com/Lorin-Lange/Advent-of-Code-2022&#34;&gt;more&lt;/a&gt;? &lt;a href=&#34;https://github.com/prikhi/advent-of-code-2022&#34;&gt;And&lt;/a&gt; &amp;mdash; &lt;a href=&#34;https://github.com/Sheinxy/Advent2022&#34;&gt;well&lt;/a&gt; &amp;mdash; &lt;a href=&#34;https://github.com/IndecisionTree/adventofcode2022&#34;&gt;more&lt;/a&gt;?)&lt;/p&gt;&#xA;&lt;p&gt;If you ask me, the solutions of &lt;a href=&#34;https://github.com/Sheinxy/Advent2022&#34;&gt;Sheinxy&lt;/a&gt; and &lt;a href=&#34;https://github.com/Scriptim/AdventOfCode2022&#34;&gt;Scriptim&lt;/a&gt; are great! Also, do not&#xA;miss the ones posted by &lt;a href=&#34;https://github.com/MondayMorningHaskell/AdventOfCode/tree/aoc-2022/src&#34;&gt;Monday Morning Haskell&lt;/a&gt;, although they do have some&#xA;boilerplate.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Weather prediction application</title>
      <link>https://blog.composef.org/coding/2022-12-02-weather-prediction-application/</link>
      <pubDate>Fri, 02 Dec 2022 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2022-12-02-weather-prediction-application/</guid>
      <description>&lt;p&gt;&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;&amp;lt;2023-02-27 Mon&amp;gt; &lt;/span&gt;&lt;/span&gt; Note: I have taken the application offline.&lt;/p&gt;&#xA;&lt;p&gt;I created a minimalist &lt;a href=&#34;https://dschrempf.duckdns.org/&#34;&gt;weather predicition application&lt;/a&gt; &amp;mdash; a short proof of&#xA;concept and stake.&lt;/p&gt;&#xA;&lt;p&gt;The main elements of the Haskell tech stack are:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/scotty&#34;&gt;Scotty&lt;/a&gt;: A web framework.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/lucid&#34;&gt;Lucid&lt;/a&gt;: A domain specific language for HTML.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/mcmc&#34;&gt;Mcmc&lt;/a&gt;: A Markov chain Monte Carlo sampler.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Other noteworthy components of this project:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The development environment is managed by the &lt;a href=&#34;https://github.com/NixOS/nix&#34;&gt;Nix package manager&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;The application is deployed using a &lt;a href=&#34;https://nixos.org/manual/nix/unstable/command-ref/new-cli/nix3-flake.html&#34;&gt;Nix Flake&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;For details, have a look at the &lt;a href=&#34;https://github.com/dschrempf/webapp&#34;&gt;project source code&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Parameter inference using Markov chain Monte Carlo algorithms and Haskell</title>
      <link>https://blog.composef.org/coding/2022-06-28-sample-from-a-posterior-using-markov-chain-monte-carlo-algorithms-and-haskell/</link>
      <pubDate>Tue, 28 Jun 2022 00:00:00 +0200</pubDate>
      <guid>https://blog.composef.org/coding/2022-06-28-sample-from-a-posterior-using-markov-chain-monte-carlo-algorithms-and-haskell/</guid>
      <description>&lt;p&gt;We analyze the number of worldwide airline fatal accidents:&lt;/p&gt;&#xA;&lt;div class=&#34;ox-hugo-table right-aligned&#34;&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Year&lt;/th&gt;&#xA;          &lt;th&gt;1976&lt;/th&gt;&#xA;          &lt;th&gt;1977&lt;/th&gt;&#xA;          &lt;th&gt;1978&lt;/th&gt;&#xA;          &lt;th&gt;1979&lt;/th&gt;&#xA;          &lt;th&gt;1980&lt;/th&gt;&#xA;          &lt;th&gt;1981&lt;/th&gt;&#xA;          &lt;th&gt;1982&lt;/th&gt;&#xA;          &lt;th&gt;1983&lt;/th&gt;&#xA;          &lt;th&gt;1984&lt;/th&gt;&#xA;          &lt;th&gt;1985&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Fatalities&lt;/td&gt;&#xA;          &lt;td&gt;24&lt;/td&gt;&#xA;          &lt;td&gt;25&lt;/td&gt;&#xA;          &lt;td&gt;31&lt;/td&gt;&#xA;          &lt;td&gt;31&lt;/td&gt;&#xA;          &lt;td&gt;22&lt;/td&gt;&#xA;          &lt;td&gt;21&lt;/td&gt;&#xA;          &lt;td&gt;26&lt;/td&gt;&#xA;          &lt;td&gt;20&lt;/td&gt;&#xA;          &lt;td&gt;16&lt;/td&gt;&#xA;          &lt;td&gt;22&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;This table is an excerpt of Table 2.2 in Gelman, Andrew and Carlin, John B and Stern, Hal S and Rubin, Donald B (2014).&lt;/p&gt;&#xA;&lt;p&gt;We assume that the number of fatal accidents \(X\) is &lt;a href=&#34;https://en.wikipedia.org/wiki/Poisson_distribution&#34;&gt;Poisson distributed&lt;/a&gt; with&#xA;fatal accident rate \(\lambda\)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Encyclopedia of Markov chain Monte Carlo methods</title>
      <link>https://blog.composef.org/coding/2020-11-12-encyclopedia-of-markov-chain-monte-carlo-methods/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2020-11-12-encyclopedia-of-markov-chain-monte-carlo-methods/</guid>
      <description>&lt;p&gt;I started this encyclopedic overview because in the Markov chain Monte Carlo&#xA;(MCMC) community many people call the same or similar concepts by very different&#xA;names. Please let me know, if you have suggestions or comments, or if you would&#xA;like to add some definitions or synonyms to this overview.&lt;/p&gt;&#xA;&lt;h2 id=&#34;bibliography&#34;&gt;Bibliography&lt;/h2&gt;&#xA;&lt;h3 id=&#34;books&#34;&gt;Books&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The nomenclature here is taken from the excellent introduction to Markov chain&#xA;Monte Carlo (MCMC) methods by Geyer, Charles J (2011), Chapter 1 in&#xA;Brooks, Steve and Gelman, Andrew and Jones, Galin and Meng, Xiao-Li (2011).&lt;/li&gt;&#xA;&lt;li&gt;More advanced topics such as population based MCMC methods are covered in&#xA;Liang, Faming and Liu, Chuanhai and Carroll, Raymond (2011).&lt;/li&gt;&#xA;&lt;li&gt;See Arnaud Doucet and Nando de Freitas and Neil Gordon (2001) for sequential Monte Carlo algorithms.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;articles&#34;&gt;Articles&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Walter R. Gilks and Carlo Berzuini (2001)&lt;/li&gt;&#xA;&lt;li&gt;Del Moral, Pierre and Doucet, Arnaud and Jasra, Ajay (2006)&lt;/li&gt;&#xA;&lt;li&gt;Andrieu, Christophe and Doucet, Arnaud and Holenstein, Roman (2010)&lt;/li&gt;&#xA;&lt;li&gt;A. {Doucet} and A. M. {Johansen} (2011)&lt;/li&gt;&#xA;&lt;li&gt;Chopin, N. and Jacob, P. E. and Papaspiliopoulos, O. (2012)&lt;/li&gt;&#xA;&lt;li&gt;Heng, Jeremy and Bishop, Adrian N. and Deligiannidis, George and Doucet, Arnaud (2020)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;articles-tailored-to-a-phylogenetic-audience&#34;&gt;Articles tailored to a phylogenetic audience&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bouchard-Côté, Alexandre and Sankararaman, Sriram and Jordan, Michael I. (2012)&lt;/li&gt;&#xA;&lt;li&gt;Vu Dinh and Aaron E Darling and Frederick A Matsen IV (2018)&lt;/li&gt;&#xA;&lt;li&gt;Mathieu Fourment and Brian C. Claywell and Vu Dinh and Connor McCoy and Frederick A. Matsen IV and Aaron E. Darling (2018)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;necessary-definitions&#34;&gt;Necessary definitions&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Elementary updates&lt;/strong&gt; are instructions about how to advance a Markov chain so&#xA;that it possibly reaches a new state. That is, elementary updates specify how&#xA;the chain traverses the state space. Elementary updates cannot be decomposed&#xA;into smaller updates.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algebraic graphs</title>
      <link>https://blog.composef.org/coding/2019-11-21-algebraic-graphs/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2019-11-21-algebraic-graphs/</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;https://hackage.haskell.org/package/algebraic-graphs&#34;&gt;Algebraic Graphs Haskell library&lt;/a&gt; (Alga) is a fast, minimalist, and elegant&#xA;approach to working with graphs that allows for equational reasoning about the&#xA;correctness of algorithms. For reference, please also see the &lt;a href=&#34;https://github.com/snowleopard/alga-paper&#34;&gt;accompanying&#xA;paper&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The advantages are:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;algebraic graphs have a small core with just four graph construction primitives;&lt;/li&gt;&#xA;&lt;li&gt;the core has a mathematical structure characterized by a set of laws or&#xA;properties.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;A &lt;strong&gt;directed graph&lt;/strong&gt; in the mathematical sense is a set \(V\) of vertices \(v_i\)&#xA;together with a set \(E\) of directed edges \((v_i, v_j)\), and is denoted&#xA;\((V,E)\). The beauty about algebraic graphs is that they are not defined&#xA;explicitly by lists of vertices and edges but in a recursive manner, similar to&#xA;the definition of algebraic trees.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Markov chains in Haskell</title>
      <link>https://blog.composef.org/coding/2018-02-10-markov-chains-in-haskell/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2018-02-10-markov-chains-in-haskell/</guid>
      <description>&lt;p&gt;I have been working on Markov chains for quite a while now and wanted to assess how&#xA;Haskell can deal with simulating a simple, discrete chain.&lt;/p&gt;&#xA;&lt;p&gt;Many sources can be found online. The code presented here is partly taken from a&#xA;&lt;a href=&#34;https://stackoverflow.com/questions/25286816/generating-sequence-from-markov-chain-in-haskell&#34;&gt;question on stackoverflow&lt;/a&gt;. However, I was unsatisfied with the nomenclature and&#xA;parts of the code. So I refactored most of it. Also, there is a Haskell library&#xA;&lt;a href=&#34;https://hackage.haskell.org/package/markov-chain&#34;&gt;markov-chain&lt;/a&gt;, which I am unsatisfied with because of code readability (it&amp;rsquo;s&#xA;pretty abstruse). Furthermore, I looked through a lengthy post about using&#xA;Markov chains to simulate &lt;a href=&#34;https://idontgetoutmuch.wordpress.com/2013/12/07/haskell-ising-markov-metropolis/&#34;&gt;interaction of magnetic spins&lt;/a&gt; using the Ising model.&#xA;The concept of a Markov chain is explained well in this article but I believe&#xA;that the example is too complicated to understand in a reasonable amount of&#xA;time. Also, the &lt;a href=&#34;https://hackage.haskell.org/package/repa&#34;&gt;Repa package&lt;/a&gt; is used to represent the transition matrices. This&#xA;seemed a little bit of an overkill to me, so I decided to go with &lt;a href=&#34;http://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Map-Strict.html&#34;&gt;maps&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Happy folding around monads in Haskell</title>
      <link>https://blog.composef.org/coding/2017-07-20-folding-around-monads-in-haskell/</link>
      <pubDate>Thu, 20 Jul 2017 00:00:00 +0200</pubDate>
      <guid>https://blog.composef.org/coding/2017-07-20-folding-around-monads-in-haskell/</guid>
      <description>&lt;p&gt;Folds are complicated themselves, but monadic folds always have blown my mind.&#xA;In what follows, I try to dissect &lt;code&gt;foldlM&lt;/code&gt; for a specific example.&lt;/p&gt;&#xA;&lt;p&gt;Monadic folds can be used to &lt;strong&gt;perform a series of actions that depend on the&#xA;previous output&lt;/strong&gt;. The following function produces an &lt;em&gt;action b&lt;/em&gt; from a &lt;em&gt;value a&lt;/em&gt;&#xA;also taking into account the output of the previous &lt;em&gt;action b&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And here the definition of &lt;code&gt;foldlM&lt;/code&gt; (which is the same as &lt;code&gt;foldM&lt;/code&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>A simulator for continuous-time Markov chains</title>
      <link>https://blog.composef.org/coding/2016-04-09-continuous-time-markov-chain/</link>
      <pubDate>Sat, 09 Apr 2016 00:00:00 +0200</pubDate>
      <guid>https://blog.composef.org/coding/2016-04-09-continuous-time-markov-chain/</guid>
      <description>&lt;p&gt;&lt;span class=&#34;timestamp-wrapper&#34;&gt;&lt;span class=&#34;timestamp&#34;&gt;[2016-04-09 Sat] &lt;/span&gt;&lt;/span&gt; I extended &lt;a href=&#34;https://blog.composef.org/coding/2015-03-26-popgen-cpp-programs/&#34;&gt;my set of C++ programs&lt;/a&gt; to include a&#xA;simulator for generic continuous-time Markov chains.  I.e., any&#xA;transition rate matrix can be used.&lt;/p&gt;&#xA;&lt;p&gt;If you are interested, just get the &lt;a href=&#34;https://github.com/dschrempf/popgen-cpp-programs&#34;&gt;GitHub repository&lt;/a&gt; and compile the&#xA;whole set of programs with &lt;code&gt;make all&lt;/code&gt;.  Documentation can be found in&#xA;the &lt;code&gt;doc/&lt;/code&gt; folder (check the &lt;code&gt;CTMC&lt;/code&gt; class).&lt;/p&gt;&#xA;&lt;p&gt;There is a sample program &lt;code&gt;src/moran_model_boundary_mutation&lt;/code&gt;, that&#xA;runs the Moran model with boundary mutation (De Maio, N., Schrempf,&#xA;D., &amp;amp; Kosiol, C. (2015). PoMo: An Allele Frequency-Based Approach for&#xA;Species Tree Estimation. Systematic Biology, 64(6),&#xA;1018–1031. &lt;a href=&#34;https://doi.org/10.1093/sysbio/syv048)&#34;&gt;https://doi.org/10.1093/sysbio/syv048)&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Population genetics C&#43;&#43; programs</title>
      <link>https://blog.composef.org/coding/2015-03-26-popgen-cpp-programs/</link>
      <pubDate>Thu, 26 Mar 2015 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2015-03-26-popgen-cpp-programs/</guid>
      <description>&lt;p&gt;I maintain a &lt;a href=&#34;https://github.com/fazky/popgen-cpp-programs&#34;&gt;Github repository&lt;/a&gt; that contains a bunch of very basic C++ programs&#xA;that use Markov chains and other types of simulations to infer basic statistical&#xA;parameters. The applications mainly focus on Population Genetics problems,&#xA;although this is not always the case. At the moment, the list of programs is:&lt;/p&gt;&#xA;&lt;dl&gt;&#xA;&lt;dt&gt;&lt;code&gt;bookshelf.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Bookshelf Markov chain&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;brownian_motion_mcmc.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Simulate standard Brownian motion&#xA;(Wiener process)&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;coin_toss_mcmc.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Run a coin toss MCMC simulation&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;cube_mcmc.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Simulation of a Markov chain that moves around the&#xA;eight vertices of a cube&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;ehrenfest_mcmc.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Simulate gas particles in a divided box&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;general_discrete_distributions.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Given K discrete events with&#xA;different probabilities P[k], produce a random value k consistent&#xA;with its probability&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;general_discrete_markov_chain.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Simulate a general discrete&#xA;Markov chain with a given transition probability matrix P&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;genetic_drift.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Simulate genetic drift&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;hitchhiking.c&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Simulate hitchhiking along a positively selected locus&lt;/dd&gt;&#xA;&lt;dt&gt;&lt;code&gt;stepping_stone_model.cpp&lt;/code&gt;&lt;/dt&gt;&#xA;&lt;dd&gt;Simulate Stepping Stone Model with a&#xA;Markov chain&lt;/dd&gt;&#xA;&lt;/dl&gt;&#xA;&lt;p&gt;Please check out the detailed &lt;a href=&#34;https://github.com/fazky/popgen-cpp-programs/tree/master/doc/html&#34;&gt;documentation on the github repository&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A simple MCMC simulation</title>
      <link>https://blog.composef.org/coding/2015-01-15-mcmc-coin-toss/</link>
      <pubDate>Thu, 15 Jan 2015 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2015-01-15-mcmc-coin-toss/</guid>
      <description>&lt;p&gt;Suppose we observe 58 heads out of 100 coin tosses. Now, we want to know the&#xA;probability of tossing a head \(\theta\). A maximum likelihood guess would be&#xA;\(\theta = 0.58\) because then, the probability of observing 58 heads&lt;/p&gt;&#xA;&lt;p&gt;\begin{align}&#xA;P(58 \mathrm{ heads}) = {100 \choose 58} (0.58)^{58} (0.42)^{42}&#xA;\end{align}&lt;/p&gt;&#xA;&lt;p&gt;is greatest (an example of the binomial distribution).&lt;/p&gt;&#xA;&lt;p&gt;However, we could also use a Bayesian approach to calculate the posterior&#xA;distribution of the probability \(\theta\) (i.e., the probability that&#xA;\(\theta\) is a certain value conditioned on our observation).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Easy pretty print in Haskell</title>
      <link>https://blog.composef.org/coding/2014-12-23-haskell-pretty-print/</link>
      <pubDate>Tue, 23 Dec 2014 00:00:00 +0100</pubDate>
      <guid>https://blog.composef.org/coding/2014-12-23-haskell-pretty-print/</guid>
      <description>&lt;p&gt;I repeatedly struggle with GHCi when I want to print lists and maps and actually&#xA;look at them and analyze them. Today I came accross &lt;a href=&#34;https://hackage.haskell.org/package/pretty-show&#34;&gt;pretty-show&lt;/a&gt;, a haskell&#xA;package that allows pretty printing of all objects that are instances of the&#xA;type class Show.&lt;/p&gt;&#xA;&lt;p&gt;The usage is very straight forward:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Text.Show.Pretty&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Pr&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This provides Pr.ppShow which can be used in GHCi (or other interpreters):&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:2;-o-tab-size:2;tab-size:2;&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;putStrLn&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;Pr&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ppShow&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;object&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
